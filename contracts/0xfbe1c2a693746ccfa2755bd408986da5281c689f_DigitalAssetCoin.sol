// DAC Contract Address: 0x800deede5d02713616498cdfd8bc5780964deb9a
// ABI: [{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;name&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_spender&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;approve&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;totalSupply&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;totalSupply&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_from&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_to&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;transferFrom&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_from&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;name&quot;:&quot;tokenAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;tokenName&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;tokenSymbol&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;transmuteTransfer&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;decimals&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint8&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;_totalSupply&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;standard&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_owner&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;balanceOf&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;balance&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;toCheck&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;vaildBalanceForTokenCreation&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;coinsAmount&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;name&quot;:&quot;initialSupply&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;name&quot;:&quot;assetTokenName&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;tokenSymbol&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;_assetID&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;_assetMeta&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;_isVerified&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;CreateDigitalAssetToken&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;owner&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;totalAssetTokens&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[],&quot;name&quot;:&quot;symbol&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_newOwner&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;changeOwner&quot;,&quot;outputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_to&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;transfer&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;assetToken&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;doesAssetTokenExist&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;success&quot;,&quot;type&quot;:&quot;bool&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:false,&quot;inputs&quot;:[{&quot;name&quot;:&quot;idx&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;getAssetTokenByIndex&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;assetToken&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;constant&quot;:true,&quot;inputs&quot;:[{&quot;name&quot;:&quot;_owner&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;name&quot;:&quot;_spender&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;allowance&quot;,&quot;outputs&quot;:[{&quot;name&quot;:&quot;remaining&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;view&quot;,&quot;type&quot;:&quot;function&quot;},{&quot;inputs&quot;:[],&quot;payable&quot;:false,&quot;stateMutability&quot;:&quot;nonpayable&quot;,&quot;type&quot;:&quot;constructor&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_creator&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_assetContract&quot;,&quot;type&quot;:&quot;address&quot;}],&quot;name&quot;:&quot;NewDigitalAsset&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_from&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_to&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_tokenAddress&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_tokenName&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_tokenSymbol&quot;,&quot;type&quot;:&quot;string&quot;}],&quot;name&quot;:&quot;TransmutedTransfer&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_from&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_to&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;Transfer&quot;,&quot;type&quot;:&quot;event&quot;},{&quot;anonymous&quot;:false,&quot;inputs&quot;:[{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_owner&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:true,&quot;name&quot;:&quot;_spender&quot;,&quot;type&quot;:&quot;address&quot;},{&quot;indexed&quot;:false,&quot;name&quot;:&quot;_value&quot;,&quot;type&quot;:&quot;uint256&quot;}],&quot;name&quot;:&quot;Approval&quot;,&quot;type&quot;:&quot;event&quot;}]
//
// Test Asset Created with owner &amp; _isVerified : 0x7962e319eDCB6afEabb0d72bb245A23d2266e3AD

pragma solidity ^0.4.10;

contract SafeMath {

    /* function assert(bool assertion) internal { */
    /*   if (!assertion) { */
    /*     throw; */
    /*   } */
    /* }      // assert no longer needed once solidity is on 0.4.10 */

    function safeToAdd(uint a, uint b) internal returns (bool) {
        return (a + b &gt;= a);
    }

    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z &gt;= x) &amp;&amp; (z &gt;= y));
      return z;
    }

    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
      assert(x &gt;= y);
      uint256 z = x - y;
      return z;
    }

    function safeMult(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x * y;
      assert((x == 0)||(z/x == y));
      return z;
    }

}

contract Token {
    uint256 public _totalSupply;
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
    function approve(address _spender, uint256 _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}


/*  ERC 20 token */
contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
      if (balances[msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      if (balances[_from] &gt;= _value &amp;&amp; allowed[_from][msg.sender] &gt;= _value &amp;&amp; _value &gt; 0) {
        balances[_to] += _value;
        balances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
      } else {
        return false;
      }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    function totalSupply() constant returns (uint256 totalSupply) {
          totalSupply = _totalSupply;
    }

    mapping (address =&gt; uint256) balances;
    mapping (address =&gt; mapping (address =&gt; uint256)) allowed;
}
  
contract DigitalAssetToken is StandardToken() 
{
    string public constant standard = &#39;DigitalAssetToken 1.0&#39;;
    string public symbol;
    string public  name;
    string public  assetID;
    string public  assetMeta;
    string public isVerfied;
    uint8 public constant decimals = 0;
   
    // Constructor
    function DigitalAssetToken(
    address tokenMaster,
    address requester,
    uint256 initialSupply,
    string assetTokenName,
    string tokenSymbol,
    string _assetID,
    string _assetMeta
    ) {
        //Only Token Master can initiate Digital Asset Token Creations
        require(msg.sender == tokenMaster);

        DigitalAssetCoin coinMaster = DigitalAssetCoin(tokenMaster);

        require(coinMaster.vaildBalanceForTokenCreation(requester));
        
        balances[requester] = initialSupply;              // Give the creator all initial tokens
        _totalSupply = initialSupply;                        // Update total supply
        name = assetTokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
        assetID = _assetID;
        assetMeta = _assetMeta;
    } 
}
  
contract DigitalAssetCoin is StandardToken {
    string public constant standard = &#39;DigitalAssetCoin 1.0&#39;;
    string public constant symbol = &quot;DAC&quot;;
    string public constant name = &quot;Digital Asset Coin&quot;;
    uint8 public constant decimals = 0;

    // Balances for each account
    mapping(address =&gt; uint256) transmutedBalances;

    // Triggered whenever approve(address _spender, uint256 _value) is called.
    event NewDigitalAsset(address indexed _creator, address indexed _assetContract);
    event TransmutedTransfer(address indexed _from, address indexed _to, uint256 _value, address _tokenAddress, string _tokenName, string _tokenSymbol);

    //List of Asset Tokens
    uint256 public totalAssetTokens;
    address[] addressList;
    mapping(address =&gt; uint256) addressDict;
    
    // Owner of this contract
    address public owner;

    // Functions with this modifier can only be executed by the owner
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    // Allow Owner to be changed by exisiting owner (Dev management)
    function changeOwner(address _newOwner) onlyOwner() {
        owner = _newOwner;
    }

    // Constructor
    function DigitalAssetCoin() {
        owner = msg.sender;
        _totalSupply = 100000000000;
        balances[owner] = _totalSupply;
        totalAssetTokens = 0;
        addressDict[this] = totalAssetTokens;
        addressList.length = 1;
        addressList[totalAssetTokens] = this;
    }

    function CreateDigitalAssetToken(
    uint256 coinsAmount,
    uint256 initialSupply,
    string assetTokenName,
    string tokenSymbol,
    string _assetID,
    string _assetMeta
    ) {
        //Not Enought Coins to Create new Asset Token
        require(balanceOf(msg.sender) &gt; coinsAmount);
        
        //Cant be smaller than 1 or larger than 1
        require(coinsAmount == 1);

        //Send coins back to master escrow
        DigitalAssetToken newToken = new DigitalAssetToken(this, msg.sender,initialSupply,assetTokenName,tokenSymbol,_assetID,_assetMeta);
        //Use coins for Token Creation
        transmuteTransfer(msg.sender, 1, newToken, assetTokenName, tokenSymbol);
        insetAssetToken(newToken);
    }

    function vaildBalanceForTokenCreation (address toCheck) external returns (bool success) {
        address sender = msg.sender;
        address org = tx.origin; 
        address tokenMaster = this;

        //Can not be run from human or master contract
        require(sender != org || sender != tokenMaster);

        //Check if message send can make token
        if (balances[toCheck] &gt;= 1) {
            return true;
        } else {
            return false;
        }

    }
    
    function insetAssetToken(address assetToken) internal {
        totalAssetTokens = totalAssetTokens + 1;
        addressDict[assetToken] = totalAssetTokens;
        addressList.length += 1;
        addressList[totalAssetTokens] = assetToken;
        NewDigitalAsset(msg.sender, assetToken);
        //Transfer(msg.sender, assetToken, 777);
    }
    
    function getAssetTokenByIndex (uint256 idx) external returns (address assetToken) {
        require(totalAssetTokens &lt;= idx);
        return addressList[idx];
    }
    
    function doesAssetTokenExist (address assetToken) external returns (bool success) {
        uint256 value = addressDict[assetToken];
        if(value == 0)
            return false;
        else
            return true;
    }
    
    // Transmute DAC to DAT
    function transmuteTransfer(address _from, uint256 _value, address tokenAddress, string tokenName, string tokenSymbol) returns (bool success) {
        if (balances[_from] &gt;= _value &amp;&amp; _value &gt; 0) {
            balances[_from] -= _value;
            transmutedBalances[this] += _value;
            TransmutedTransfer(_from, this, _value, tokenAddress, tokenName, tokenSymbol);
            return true;
        } else {
            return false;
        }
    }

}